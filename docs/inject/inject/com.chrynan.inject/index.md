//[inject](../../index.md)/[com.chrynan.inject](index.md)

# Package-level declarations

## Types

| Name | Summary |
|---|---|
| [Inject](-inject/index.md) | [common]<br>@[Target](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html)(allowedTargets = [[AnnotationTarget.FUNCTION](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-u-n-c-t-i-o-n/index.html), [AnnotationTarget.CONSTRUCTOR](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r/index.html), [AnnotationTarget.PROPERTY](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y/index.html), [AnnotationTarget.FIELD](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-i-e-l-d/index.html)])<br>expect annotation class [Inject](-inject/index.md)<br>Identifies injectable constructors, methods, and fields. May apply to static as well as instance members. An injectable member may have any access modifier (private, package-private, protected, public). Constructors are injected first, followed by fields, and then methods. Fields and methods in superclasses are injected before those in subclasses. Ordering of injection among fields and among methods in the same class is not specified.<br>[js, android, jvm]<br>[js]<br>actual annotation class [Inject](-inject/index.md)<br>[android, jvm]<br>actual typealias [Inject](-inject/index.md) = Inject |
| [Named](-named/index.md) | [common]<br>@[Qualifier](-qualifier/index.md)<br>expect annotation class [Named](-named/index.md)(val value: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html))<br>String-based {@linkplain Qualifier qualifier}.<br>[js, android, jvm]<br>[js]<br>actual annotation class [Named](-named/index.md)(val value: [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html))<br>[android, jvm]<br>actual typealias [Named](-named/index.md) = Named |
| [Provider](-provider/index.md) | [common]<br>expect interface [Provider](-provider/index.md)&lt;[T](-provider/index.md)&gt;<br>Provides instances of {@code T}. Typically implemented by an injector. For any type {@code T} that can be injected, you can also inject {@code Provider<T>}. Compared to injecting {@code T} directly, injecting {@code Provider<T>} enables:<br>[js, android, jvm]<br>[js]<br>actual interface [Provider](-provider/index.md)&lt;[T](-provider/index.md)&gt;<br>[android, jvm]<br>actual typealias [Provider](-provider/index.md) = Provider&lt;[T](-provider/index.md)&gt; |
| [Qualifier](-qualifier/index.md) | [common]<br>@[Target](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html)(allowedTargets = [[AnnotationTarget.ANNOTATION_CLASS](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-a-n-n-o-t-a-t-i-o-n_-c-l-a-s-s/index.html)])<br>expect annotation class [Qualifier](-qualifier/index.md)<br>Identifies qualifier annotations. Anyone can define a new qualifier. A qualifier annotation:<br>[js, android, jvm]<br>[js]<br>actual annotation class [Qualifier](-qualifier/index.md)<br>[android, jvm]<br>actual typealias [Qualifier](-qualifier/index.md) = Qualifier |
| [Scope](-scope/index.md) | [common]<br>@[Target](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html)(allowedTargets = [[AnnotationTarget.ANNOTATION_CLASS](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-a-n-n-o-t-a-t-i-o-n_-c-l-a-s-s/index.html)])<br>expect annotation class [Scope](-scope/index.md)<br>Identifies scope annotations. A scope annotation applies to a class containing an injectable constructor and governs how the injector reuses instances of the type. By default, if no scope annotation is present, the injector creates an instance (by injecting the type's constructor), uses the instance for one injection, and then forgets it. If a scope annotation is present, the injector may retain the instance for possible reuse in a later injection. If multiple threads can access a scoped instance, its implementation should be thread safe. The implementation of the scope itself is left up to the injector.<br>[js, android, jvm]<br>[js]<br>actual annotation class [Scope](-scope/index.md)<br>[android, jvm]<br>actual typealias [Scope](-scope/index.md) = Scope |
| [Singleton](-singleton/index.md) | [common]<br>@[Scope](-scope/index.md)<br>expect annotation class [Singleton](-singleton/index.md)<br>Identifies a type that the injector only instantiates once. Not inherited.<br>[js, android, jvm]<br>[js]<br>actual annotation class [Singleton](-singleton/index.md)<br>[android, jvm]<br>actual typealias [Singleton](-singleton/index.md) = Singleton |
